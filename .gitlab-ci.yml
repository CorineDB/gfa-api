stages:
  - deploy
  - health_check

variables:
  # DEPLOY_TARGET: Where to deploy
  #   - "server" (default): Uses SSH_HOST, SSH_USER, SSH_PASSWORD
  #   - "pc": Uses LOCAL_SSH_HOST, LOCAL_SSH_USER, LOCAL_SSH_PASSWORD
  DEPLOY_TARGET: "server"

before_script:
  - 'which sshpass || (apt-get update -y && apt-get install -y sshpass)'

# =============================================================================
# DEPLOY STAGE
# =============================================================================

deploy_production:
  stage: deploy
  only:
    - corine
  script:
    - |
      # Select SSH credentials and project path based on DEPLOY_TARGET
      if [ "$DEPLOY_TARGET" = "pc" ]; then
        echo "ðŸ–¥ï¸  Deploying to LOCAL PC..."
        TARGET_HOST="${LOCAL_SSH_HOST}"
        TARGET_USER="${LOCAL_SSH_USER}"
        TARGET_PASSWORD="${LOCAL_SSH_PASSWORD}"
        PROJECT_PATH="${LOCAL_PROJECT_PATH:-/var/www/html/gfa/gfa_se_backend_webapp}"
      else
        echo "ðŸŒ Deploying to PRODUCTION SERVER..."
        TARGET_HOST="${SSH_HOST}"
        TARGET_USER="${SSH_USER}"
        TARGET_PASSWORD="${SSH_PASSWORD}"
        PROJECT_PATH="${SERVER_PROJECT_PATH:-/usr/local/lsws/gfa_se_backend_webapp}"
      fi
      
      echo "Project path: $PROJECT_PATH"
      
      # Gestion des variables d'environnement
      # PrioritÃ©: 1) ENV_FILE (GitLab CI/CD), 2) .env.production.example
      if [ -n "$ENV_FILE" ]; then
        echo "Using ENV_FILE from GitLab CI/CD variables..."
        ENV_CONTENT=$(cat $ENV_FILE)
      elif [ -f .env.production.example ]; then
        echo "Using .env.production.example..."
        ENV_CONTENT=$(cat .env.production.example)
      else
        echo "ERROR: No ENV_FILE or .env.production.example found!"
        exit 1
      fi

      # DÃ©ploiement sur le serveur
      sshpass -p "$TARGET_PASSWORD" ssh -o StrictHostKeyChecking=no \
      -o UserKnownHostsFile=/dev/null \
      $TARGET_USER@$TARGET_HOST "
        set -e
        echo 'Starting Docker deployment...'

        # AccÃ©der au rÃ©pertoire du projet
        cd $PROJECT_PATH || exit 1


        # Pull des derniÃ¨res modifications
        echo 'Pulling latest changes...'
        git pull origin main || exit 1

        # Ã‰crire le fichier .env.production
        echo 'Writing .env.production...'
        cat > .env.production << 'ENVEOF'
$ENV_CONTENT
ENVEOF

        # VÃ©rifier les variables requises
        source .env.production
        
        # Database
        if [ -z \"\$DB_PASSWORD\" ]; then
          echo 'ERROR: DB_PASSWORD is not set'
          exit 1
        fi
        
        # Mail
        if [ -z \"\$MAIL_PASSWORD\" ]; then
          echo 'ERROR: MAIL_PASSWORD is not set'
          exit 1
        fi
        
        # Frontend URLs
        if [ -z \"\$UG_APP_URL\" ]; then
          echo 'ERROR: UG_APP_URL is not set'
          exit 1
        fi
        if [ -z \"\$ORG_APP_URL\" ]; then
          echo 'ERROR: ORG_APP_URL is not set'
          exit 1
        fi
        if [ -z \"\$ADMIN_APP_URL\" ]; then
          echo 'ERROR: ADMIN_APP_URL is not set'
          exit 1
        fi
        
        # SMS Provider
        if [ -z \"\$SMS_PROVIDER_API_KEY\" ]; then
          echo 'ERROR: SMS_PROVIDER_API_KEY is not set'
          exit 1
        fi
        
        # Alerts
        if [ -z \"\$ALERT_EMAIL\" ]; then
          echo 'ERROR: ALERT_EMAIL is not set'
          exit 1
        fi
        
        echo 'Environment validated successfully!'
        echo '  APP_URL='\$APP_URL
        echo '  UG_APP_URL='\$UG_APP_URL

        # RedÃ©marrage des conteneurs avec config production
        echo 'Rebuilding and restarting containers...'
        docker-compose --env-file .env.production -f docker-compose.yml -f docker-compose.prod.yml up -d --build --remove-orphans || exit 1

        # Optimisations pour la production (Cache)
        echo 'Optimizing configuration...'
        docker-compose exec -T app php artisan config:cache || exit 1
        docker-compose exec -T app php artisan route:cache || exit 1
        docker-compose exec -T app php artisan view:cache || exit 1

        echo 'Deploy stage completed!'
      "
  retry: 1
  when: manual
  allow_failure: false

# =============================================================================
# HEALTH CHECK STAGE
# =============================================================================

health_check:
  stage: health_check
  only:
    - corine
  needs:
    - deploy_production
  script:
    - |
      # Select SSH credentials and project path based on DEPLOY_TARGET
      if [ "$DEPLOY_TARGET" = "pc" ]; then
        TARGET_HOST="${LOCAL_SSH_HOST}"
        TARGET_USER="${LOCAL_SSH_USER}"
        TARGET_PASSWORD="${LOCAL_SSH_PASSWORD}"
        PROJECT_PATH="${LOCAL_PROJECT_PATH:-/var/www/html/gfa/gfa_se_backend_webapp}"
      else
        TARGET_HOST="${SSH_HOST}"
        TARGET_USER="${SSH_USER}"
        TARGET_PASSWORD="${SSH_PASSWORD}"
        PROJECT_PATH="${SERVER_PROJECT_PATH:-/usr/local/lsws/gfa_se_backend_webapp}"
      fi
      
      echo "Running health checks on $PROJECT_PATH..."
      
      sshpass -p "$TARGET_PASSWORD" ssh -o StrictHostKeyChecking=no \
      -o UserKnownHostsFile=/dev/null \
      $TARGET_USER@$TARGET_HOST "
        set -e
        cd $PROJECT_PATH || exit 1

        echo '========================================='
        echo 'HEALTH CHECKS'
        echo '========================================='
        
        # Test storage permissions - logs
        echo 'Checking storage/logs write permissions...'
        docker-compose exec -T app sh -c 'echo \"test\" > /var/www/html/storage/logs/health-check.log && rm /var/www/html/storage/logs/health-check.log' || {
          echo 'ERROR: Cannot write to storage/logs'
          exit 1
        }
        echo '  âœ“ storage/logs OK'
        
        # Test storage permissions - private
        echo 'Checking storage/app/private write permissions...'
        docker-compose exec -T app sh -c 'mkdir -p /var/www/html/storage/app/private && echo \"test\" > /var/www/html/storage/app/private/health-check.txt && rm /var/www/html/storage/app/private/health-check.txt' || {
          echo 'ERROR: Cannot write to storage/app/private'
          exit 1
        }
        echo '  âœ“ storage/app/private OK'
        
        # Test storage permissions - public
        echo 'Checking storage/app/public write permissions...'
        docker-compose exec -T app sh -c 'mkdir -p /var/www/html/storage/app/public && echo \"test\" > /var/www/html/storage/app/public/health-check.txt && rm /var/www/html/storage/app/public/health-check.txt' || {
          echo 'ERROR: Cannot write to storage/app/public'
          exit 1
        }
        echo '  âœ“ storage/app/public OK'
        
        # Test mail configuration
        echo 'Checking mail configuration...'
        docker-compose exec -T app php artisan tinker --execute=\"config('mail.mailers.smtp.host');\" 2>/dev/null || echo '  âš  Mail check via tinker skipped'
        echo '  âœ“ Mail config loaded'
        
        # Test database connection
        echo 'Checking database connection...'
        docker-compose exec -T app php artisan db:show 2>/dev/null || docker-compose exec -T app php artisan migrate:status | head -5
        echo '  âœ“ Database connection OK'
        
        # Test Redis connection (used by queue)
        echo 'Checking Redis connection...'
        docker-compose exec -T app php artisan tinker --execute=\"Redis::ping();\" 2>/dev/null && echo '  âœ“ Redis connection OK' || echo '  âš  Redis check skipped'
        
        # Test Worker is running
        echo 'Checking worker container...'
        docker ps --filter name=gfa_worker --format '{{.Status}}' | grep -q 'Up' && echo '  âœ“ Worker container is running' || {
          echo 'ERROR: Worker container is not running'
          docker-compose logs --tail=10 worker
          exit 1
        }
        
        # Test Scheduler is running
        echo 'Checking scheduler container...'
        docker ps --filter name=gfa_scheduler --format '{{.Status}}' | grep -q 'Up' && echo '  âœ“ Scheduler container is running' || {
          echo 'ERROR: Scheduler container is not running'
          docker-compose logs --tail=10 scheduler
          exit 1
        }
        
        # Test queue is processing (optional - just info)
        echo 'Checking queue status...'
        docker-compose exec -T app php artisan queue:monitor 2>/dev/null || docker-compose exec -T app php artisan queue:work --once --tries=1 2>/dev/null && echo '  âœ“ Queue processing OK' || echo '  âš  Queue test skipped'
        
        echo ''
        echo '========================================='
        echo 'All health checks passed!'
        echo '========================================='
      "
  when: on_success
  allow_failure: false
