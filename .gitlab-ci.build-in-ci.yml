# ALTERNATIVE APPROACH: Build image in CI runner, then deploy to server
# To use this file, rename it to .gitlab-ci.yml
# This approach builds the Docker image in GitLab CI, transfers it to the server,
# then runs docker-compose with the pre-built image.

stages:
  - build
  - deploy
  - health_check

variables:
  DOCKER_IMAGE: gfa_backend_app
  # DEPLOY_TARGET: Where to deploy
  #   - "server" (default): Uses SSH_HOST, SSH_USER, SSH_PASSWORD
  #   - "pc": Uses LOCAL_SSH_HOST, LOCAL_SSH_USER, LOCAL_SSH_PASSWORD
  DEPLOY_TARGET: "server"

before_script:
  - 'which sshpass || (apt-get update -y && apt-get install -y sshpass)'

# =============================================================================
# BUILD STAGE - Build image in GitLab CI runner
# =============================================================================

build:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  script:
    - |
      echo "Building Backend App image..."
      
      # Build the backend app image
      docker build -t $DOCKER_IMAGE:latest .
      
      # Save image for deploy stage
      docker save $DOCKER_IMAGE:latest > image.tar
      
      echo "Image built successfully!"
  artifacts:
    paths:
      - image.tar
    expire_in: 1 hour
  only:
    - corine

# =============================================================================
# DEPLOY STAGE - Transfer image and start containers on server
# =============================================================================

deploy:
  stage: deploy
  dependencies:
    - build
  script:
    - |
      # Select SSH credentials and project path based on DEPLOY_TARGET
      if [ "$DEPLOY_TARGET" = "pc" ]; then
        echo "üñ•Ô∏è  Deploying to LOCAL PC..."
        TARGET_HOST="${LOCAL_SSH_HOST}"
        TARGET_USER="${LOCAL_SSH_USER}"
        TARGET_PASSWORD="${LOCAL_SSH_PASSWORD}"
        PROJECT_PATH="${LOCAL_PROJECT_PATH:-/var/www/html/gfa/gfa_se_backend_webapp}"
      else
        echo "üåê Deploying to PRODUCTION SERVER..."
        TARGET_HOST="${SSH_HOST}"
        TARGET_USER="${SSH_USER}"
        TARGET_PASSWORD="${SSH_PASSWORD}"
        PROJECT_PATH="${SERVER_PROJECT_PATH:-/usr/local/lsws/gfa_se_backend_webapp}"
      fi
      
      # Gestion des variables d'environnement
      # Priorit√©: 1) ENV_FILE (GitLab CI/CD), 2) .env.production.example
      if [ -n "$ENV_FILE" ]; then
        echo "Using ENV_FILE from GitLab CI/CD variables..."
        ENV_CONTENT=$(cat $ENV_FILE)
      elif [ -f .env.production.example ]; then
        echo "Using .env.production.example..."
        ENV_CONTENT=$(cat .env.production.example)
      else
        echo "ERROR: No ENV_FILE or .env.production.example found!"
        exit 1
      fi

      echo "Transferring image to server..."
      
      # Transfer image to server
      sshpass -p "$TARGET_PASSWORD" scp -o StrictHostKeyChecking=no \
        -o UserKnownHostsFile=/dev/null \
        image.tar $TARGET_USER@$TARGET_HOST:/tmp/gfa_backend_image.tar

      # Deploy on server
      sshpass -p "$TARGET_PASSWORD" ssh -o StrictHostKeyChecking=no \
      -o UserKnownHostsFile=/dev/null \
      $TARGET_USER@$TARGET_HOST "
        set -e
        echo 'Starting Backend deployment...'

        # Navigate to project directory
        cd $PROJECT_PATH || exit 1

        # Pull latest changes (for docker-compose.yml, configs, etc.)
        echo 'Pulling latest changes...'
        git pull origin main || exit 1

        # Load the pre-built image
        echo 'Loading Docker image...'
        docker load < /tmp/gfa_backend_image.tar
        rm /tmp/gfa_backend_image.tar

        # Write .env.production
        echo 'Writing .env.production...'
        cat > .env.production << 'ENVEOF'
$ENV_CONTENT
ENVEOF

        # V√©rifier les variables requises
        source .env.production
        
        # Database
        if [ -z \"\$DB_PASSWORD\" ]; then
          echo 'ERROR: DB_PASSWORD is not set'
          exit 1
        fi
        
        # Mail
        if [ -z \"\$MAIL_PASSWORD\" ]; then
          echo 'ERROR: MAIL_PASSWORD is not set'
          exit 1
        fi
        
        # Frontend URLs
        if [ -z \"\$UG_APP_URL\" ]; then
          echo 'ERROR: UG_APP_URL is not set'
          exit 1
        fi
        if [ -z \"\$ORG_APP_URL\" ]; then
          echo 'ERROR: ORG_APP_URL is not set'
          exit 1
        fi
        if [ -z \"\$ADMIN_APP_URL\" ]; then
          echo 'ERROR: ADMIN_APP_URL is not set'
          exit 1
        fi
        
        # SMS Provider
        if [ -z \"\$SMS_PROVIDER_API_KEY\" ]; then
          echo 'ERROR: SMS_PROVIDER_API_KEY is not set'
          exit 1
        fi
        
        # Alerts
        if [ -z \"\$ALERT_EMAIL\" ]; then
          echo 'ERROR: ALERT_EMAIL is not set'
          exit 1
        fi
        
        echo 'Environment validated successfully!'

        # Start all services with the pre-built image (no --build needed)
        echo 'Starting containers...'
        docker-compose --env-file .env.production -f docker-compose.yml -f docker-compose.prod.yml up -d --remove-orphans || exit 1

        # Wait for app to be ready
        sleep 10

        # Run Laravel optimizations
        echo 'Optimizing configuration...'
        docker-compose exec -T app php artisan config:cache || exit 1
        docker-compose exec -T app php artisan route:cache || exit 1
        docker-compose exec -T app php artisan view:cache || exit 1

        echo 'Deploy stage completed!'
      "
  only:
    - corine
  when: manual
  allow_failure: false

# =============================================================================
# HEALTH CHECK STAGE
# =============================================================================

health_check:
  stage: health_check
  only:
    - corine
  needs:
    - deploy
  script:
    - |
      # Select SSH credentials and project path based on DEPLOY_TARGET
      if [ "$DEPLOY_TARGET" = "pc" ]; then
        TARGET_HOST="${LOCAL_SSH_HOST}"
        TARGET_USER="${LOCAL_SSH_USER}"
        TARGET_PASSWORD="${LOCAL_SSH_PASSWORD}"
        PROJECT_PATH="${LOCAL_PROJECT_PATH:-/var/www/html/gfa/gfa_se_backend_webapp}"
      else
        TARGET_HOST="${SSH_HOST}"
        TARGET_USER="${SSH_USER}"
        TARGET_PASSWORD="${SSH_PASSWORD}"
        PROJECT_PATH="${SERVER_PROJECT_PATH:-/usr/local/lsws/gfa_se_backend_webapp}"
      fi
      
      echo "Running health checks on $PROJECT_PATH..."
      
      sshpass -p "$TARGET_PASSWORD" ssh -o StrictHostKeyChecking=no \
      -o UserKnownHostsFile=/dev/null \
      $TARGET_USER@$TARGET_HOST "
        set -e
        cd $PROJECT_PATH || exit 1

        echo '========================================='
        echo 'HEALTH CHECKS'
        echo '========================================='
        
        # Test storage permissions - logs
        echo 'Checking storage/logs write permissions...'
        docker-compose exec -T app sh -c 'echo \"test\" > /var/www/html/storage/logs/health-check.log && rm /var/www/html/storage/logs/health-check.log' || {
          echo 'ERROR: Cannot write to storage/logs'
          exit 1
        }
        echo '  ‚úì storage/logs OK'
        
        # Test storage permissions - private
        echo 'Checking storage/app/private write permissions...'
        docker-compose exec -T app sh -c 'mkdir -p /var/www/html/storage/app/private && echo \"test\" > /var/www/html/storage/app/private/health-check.txt && rm /var/www/html/storage/app/private/health-check.txt' || {
          echo 'ERROR: Cannot write to storage/app/private'
          exit 1
        }
        echo '  ‚úì storage/app/private OK'
        
        # Test storage permissions - public
        echo 'Checking storage/app/public write permissions...'
        docker-compose exec -T app sh -c 'mkdir -p /var/www/html/storage/app/public && echo \"test\" > /var/www/html/storage/app/public/health-check.txt && rm /var/www/html/storage/app/public/health-check.txt' || {
          echo 'ERROR: Cannot write to storage/app/public'
          exit 1
        }
        echo '  ‚úì storage/app/public OK'
        
        # Test mail configuration
        echo 'Checking mail configuration...'
        docker-compose exec -T app php artisan tinker --execute=\"config('mail.mailers.smtp.host');\" 2>/dev/null || echo '  ‚ö† Mail check via tinker skipped'
        echo '  ‚úì Mail config loaded'
        
        # Test database connection
        echo 'Checking database connection...'
        docker-compose exec -T app php artisan db:show 2>/dev/null || docker-compose exec -T app php artisan migrate:status | head -5
        echo '  ‚úì Database connection OK'
        
        # Test Redis connection (used by queue)
        echo 'Checking Redis connection...'
        docker-compose exec -T app php artisan tinker --execute=\"Redis::ping();\" 2>/dev/null && echo '  ‚úì Redis connection OK' || echo '  ‚ö† Redis check skipped'
        
        # Test Worker is running
        echo 'Checking worker container...'
        docker ps --filter name=gfa_worker --format '{{.Status}}' | grep -q 'Up' && echo '  ‚úì Worker container is running' || {
          echo 'ERROR: Worker container is not running'
          docker-compose logs --tail=10 worker
          exit 1
        }
        
        # Test Scheduler is running
        echo 'Checking scheduler container...'
        docker ps --filter name=gfa_scheduler --format '{{.Status}}' | grep -q 'Up' && echo '  ‚úì Scheduler container is running' || {
          echo 'ERROR: Scheduler container is not running'
          docker-compose logs --tail=10 scheduler
          exit 1
        }
        
        # Test queue is processing (optional - just info)
        echo 'Checking queue status...'
        docker-compose exec -T app php artisan queue:monitor 2>/dev/null || docker-compose exec -T app php artisan queue:work --once --tries=1 2>/dev/null && echo '  ‚úì Queue processing OK' || echo '  ‚ö† Queue test skipped'
        
        echo ''
        echo '========================================='
        echo 'All health checks passed!'
        echo '========================================='
      "
  when: on_success
  allow_failure: false
